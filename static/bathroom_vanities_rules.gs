/**
 * Bathroom Vanities Collection Rules - Google Apps Script
 * Auto-generated by Collection Builder
 *
 * This script handles:
 * - Data validation and cleaning
 * - Quality score calculation
 * - Rule-based field population
 * - Webhook responses for PIM system
 */

// Configuration Constants
const SPREADSHEET_ID = SpreadsheetApp.getActiveSpreadsheet().getId();
const DATA_WORKSHEET = 'Raw_Data';
const WEBHOOK_URL = 'YOUR_WEBHOOK_URL_HERE'; // Replace with your actual webhook URL

// Quality Score Fields for Bathroom Vanities
const QUALITY_SCORE_FIELDS = [
'sku', 'title', 'brand_name', 'cabinet_material', 'basin_material', 'width_mm', 'depth_mm', 'height_mm', 'door_style', 'finish', 'basin_type'
];

// Column Mappings for Bathroom Vanities
const COLUMN_MAPPINGS = {
  'url': 1,\n  'variant_sku': 2,\n  'key': 3,\n  'id': 4,\n  'handle': 5,\n  'title': 6,\n  'vendor': 7,\n  'sku': 8,\n  'brand_name': 9,\n  'cabinet_material': 10,\n  'basin_material': 11,\n  'width_mm': 12,\n  'depth_mm': 13,\n  'height_mm': 14,\n  'door_style': 15,\n  'finish': 16,\n  'basin_type': 17,\n  'shopify_price': 18,\n  'shopify_compare_price': 19,\n  'shopify_weight': 20,\n  'shopify_tags': 21,\n  'seo_title': 22,\n  'seo_description': 23,\n  'shopify_images': 24,\n  'shopify_collections': 25,\n  'shopify_url': 26,\n  'last_shopify_sync': 27
};

// Rule Type Mappings - maps column numbers to rule types
const RULE_TYPE_MAPPINGS = {
  9: 'brand',\n  16: 'finish'
};

// Rule Sheet Names
const RULE_SHEET_MAP = {
  'brandname': 'Brand_Rules',\n  'finish': 'Finish_Rules'
};

/**
 * Main entry point - called when sheet is edited
 */
function onEdit(e) {
  try {
    console.log('‚úÖ Bathroom Vanities sheet edited, processing...');

    const range = e.range;
    const row = range.getRow();
    const col = range.getColumn();

    // Skip header row
    if (row <= 1) return;

    // Process the edited cell
    processEditedCell(row, col, e.value);

    // Calculate quality score for the row
    calculateQualityScore(row);

  } catch (error) {
    console.error('‚ùå Error in onEdit:', error);
  }
}

/**
 * Process individual cell edits
 */
function processEditedCell(row, col, value) {
  if (!value) return;

  const sheet = SpreadsheetApp.getActiveSheet();

  // Apply rules based on column type
  const ruleType = RULE_TYPE_MAPPINGS[col];
  if (ruleType) {
    applyRule(sheet, row, col, value, ruleType);
  }

  // Clean and format the value
  const cleanedValue = cleanFieldValue(value, col);
  if (cleanedValue !== value) {
    sheet.getRange(row, col).setValue(cleanedValue);
  }
}

/**
 * Apply validation rules
 */
function applyRule(sheet, row, col, value, ruleType) {
  try {
    const ruleSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(RULE_SHEET_MAP[ruleType]);
    if (!ruleSheet) return;

    // Get rules data
    const rules = ruleSheet.getDataRange().getValues();

    // Find matching rule
    for (let i = 1; i < rules.length; i++) {
      const rule = rules[i];
      if (rule[0] && value.toLowerCase().includes(rule[0].toLowerCase())) {
        // Apply the rule - update cell with standardized value
        if (rule[1]) {
          sheet.getRange(row, col).setValue(rule[1]);
        }
        break;
      }
    }

  } catch (error) {
    console.error(`‚ùå Error applying rule for ${ruleType}:`, error);
  }
}

/**
 * Clean and format field values
 */
function cleanFieldValue(value, col) {
  if (!value) return value;

  let cleaned = value.toString().trim();

  // Apply column-specific cleaning
  switch(col) {
    // No specific cleaning rules
    default:
      // General cleaning
      cleaned = cleaned.replace(/\s+/g, ' ').trim();
      break;
  }

  return cleaned;
}

/**
 * Calculate quality score for a row
 */
function calculateQualityScore(row) {
  try {
    const sheet = SpreadsheetApp.getActiveSheet();
    let totalScore = 0;
    let maxScore = 0;

    // Check each quality field
    QUALITY_SCORE_FIELDS.forEach(field => {
      const col = COLUMN_MAPPINGS[field];
      if (col) {
        maxScore += 10;
        const value = sheet.getRange(row, col).getValue();
        if (value && value.toString().trim()) {
          totalScore += 10;
        }
      }
    });

    // Calculate percentage
    const qualityScore = maxScore > 0 ? Math.round((totalScore / maxScore) * 100) : 0;

    // Update quality score column (assuming it exists)
    const qualityCol = COLUMN_MAPPINGS['quality_score'];
    if (qualityCol) {
      sheet.getRange(row, qualityCol).setValue(qualityScore + '%');
    }

    console.log(`‚úÖ Quality score for row ${row}: ${qualityScore}%`);

  } catch (error) {
    console.error('‚ùå Error calculating quality score:', error);
  }
}

/**
 * Webhook endpoint for PIM system
 */
function doPost(e) {
  try {
    const data = JSON.parse(e.postData.contents);
    console.log('üì® Received webhook data:', data);

    // Process the webhook data
    const result = processWebhookData(data);

    return ContentService
      .createTextOutput(JSON.stringify(result))
      .setMimeType(ContentService.MimeType.JSON);

  } catch (error) {
    console.error('‚ùå Webhook error:', error);
    return ContentService
      .createTextOutput(JSON.stringify({error: error.toString()}))
      .setMimeType(ContentService.MimeType.JSON);
  }
}

/**
 * Process webhook data from PIM system
 */
function processWebhookData(data) {
  // Handle different webhook types
  switch(data.type) {
    case 'quality_check':
      return runQualityCheck();
    case 'bulk_update':
      return processBulkUpdate(data.updates);
    case 'export_data':
      return exportSheetData();
    default:
      return {error: 'Unknown webhook type'};
  }
}

/**
 * Run quality check on all rows
 */
function runQualityCheck() {
  try {
    const sheet = SpreadsheetApp.getActiveSheet();
    const lastRow = sheet.getLastRow();

    for (let row = 2; row <= lastRow; row++) {
      calculateQualityScore(row);
    }

    return {success: true, message: `Quality check completed for ${lastRow - 1} products`};

  } catch (error) {
    return {success: false, error: error.toString()};
  }
}

/**
 * Export sheet data for PIM system
 */
function exportSheetData() {
  try {
    const sheet = SpreadsheetApp.getActiveSheet();
    const data = sheet.getDataRange().getValues();

    return {
      success: true,
      data: data,
      lastUpdated: new Date().toISOString(),
      collection: 'bathroom_vanities'
    };

  } catch (error) {
    return {success: false, error: error.toString()};
  }
}

/**
 * Initialize Bathroom Vanities collection rules
 */
function initializeBathroomVanitiesRules() {
  console.log('üöÄ Initializing Bathroom Vanities collection rules...');

  // Create rule sheets if they don't exist
  createRuleSheets();

  // Set up initial formatting
  formatHeaders();

  console.log('‚úÖ Bathroom Vanities rules initialized successfully');
}

/**
 * Create rule sheets for validation
 */
function createRuleSheets() {
  const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();

  Object.values(RULE_SHEET_MAP).forEach(sheetName => {
    let sheet = spreadsheet.getSheetByName(sheetName);
    if (!sheet) {
      sheet = spreadsheet.insertSheet(sheetName);

      // Add headers
      sheet.getRange(1, 1, 1, 3).setValues([['Input Pattern', 'Standardized Output', 'Notes']]);
      sheet.getRange(1, 1, 1, 3).setFontWeight('bold');

      console.log(`üìã Created rule sheet: ${sheetName}`);
    }
  });
}

/**
 * Format header row
 */
function formatHeaders() {
  const sheet = SpreadsheetApp.getActiveSheet();
  const headerRange = sheet.getRange(1, 1, 1, sheet.getLastColumn());

  headerRange.setFontWeight('bold');
  headerRange.setBackground('#4285f4');
  headerRange.setFontColor('white');

  console.log('‚úÖ Headers formatted for Bathroom Vanities');
}

// Auto-run initialization when script is deployed
initializeBathroomVanitiesRules();
